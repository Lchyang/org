* python 高级编程实战练习
** 数据结构和算法案例进阶训练
*** 如何在列表，字典，集合中根据条件筛选数据？
 列表解析，filter，列表解析的速度是filter的一半左右，字典解析，集合解析
*** 如何为元组中的每个元素命名，提高程序可读性。
 设置常量，替代索引值，元组拆包。 collections中的nametuple
*** 如何统计序列中元素出现频度？
 用字典dict.fromkeys(data,0)创建字典，然后迭代每个key出现value加一
 collections 中 Counter 和 counter.most_common
*** 如何快速找到多个字典中的公共key？
 reduce(lambda a,b: a&b, map(dict.keys(),[data1, data2, data3]))
*** 如何让字典保持有序？
 collections 中 OrderedDict
*** 如何实现用户历史记录功能？
 collections 中 deque
** TODO 对象迭代与反迭代案例进阶训练
   DEADLINE: <2018-12-02 Sun 00:00>
*** 如何实现可迭代对象和迭代器对象
** TODO 字符串处理案例进阶训练
*** 如何拆分含多种分隔符的字符串
 案例：要把某个字符串依据分隔符拆分成不同的字段
 s = 'ab;cd|efg|hi,jkl|mn\topq;rst,uvw\txyz'
 其中，；\ /t都是分隔符，如何处理
 #+BEGIN_SRC python
   # split()方法
   def mySplit(s, ds):
       res = [s]
       for d in ds:
           t = []
           list(map(lambda x: t.extend(x.split(d)), res))
           res = t
       return [x for x in res if x] #当两个分隔符连续时会产生空字符串 过滤掉

   s = 'ab;cd|efg|hi,,jkl|mn\topq;rst,uvw\txyz'
   print(mySplit(s, ';,|\t'))

   # In [7]: ['ab', 'cd', 'efg', 'hi', 'jkl', 'mn', 'opq', 'rst', 'uvw', 'xyz']

   # 方法二： re 模块 re.split
   import re
   print(re.split(r'[,;|\t]+', s))
 #+END_SRC
*** 如何判断字符串a是否以字符串b结尾
 案例：某文件系统目录下有一系列文件：
 quicksort.c
 graph.py
 heap.java
 install.sh
 stack.cpp 
 ...
 编写程序给其中的所有.sh文件和.py文件加上用户权限

 解决方案：使用字符串的str.startswith()和str.endswith()方法
 #+BEGIN_SRC python
   In [18]: ls
   HelloWorld.class  c_test/           test.py           venv2/
   HelloWorld.java   test              underscores.txt

   In [19]: import os, stat

   In [20]: os.listdir('.')
   Out[20]:
   ['.DS_Store',
   'c_test',
   'HelloWorld.class',
   'HelloWorld.java',
   'test',
   'test.py',
   'underscores.txt',
   'venv2']
 # 注意endswith()参数不能是列表。
   In [29]: [name for name in os.listdir('.') if name.endswith(('.sh','.py'))]
   Out[29]: ['test.py']

   In [30]: os.stat('test.py')
   Out[30]: posix.stat_result(st_mode=33188, st_ino=10893185, st_dev=16777220,
                             st_nlink=1, st_uid=501, st_gid=20, st_size=0,
                             st_atime=1542949483, st_mtime=1542949488, st_ctime=1542949488)

   In [31]: os.stat('test.py').st_mode
   Out[31]: 33188

   In [32]: oct(os.stat('test.py').st_mode)
   Out[32]: '0100644'

   In [33]: os.chmod('test.py', os.stat('test.py').st_mode | stat.S_IXUSR)

   In [34]: ls -l
   total 32
   -rw-r--r--  1 lichunyang  staff  425  9 20 13:56 HelloWorld.class
   -rw-r--r--  1 lichunyang  staff  147  9 20 13:56 HelloWorld.java
   drwxr-xr-x  5 lichunyang  staff  170  9 24 22:41 c_test/
   -rw-r--r--  1 lichunyang  staff   62  3 14  2018 test
   -rwxr--r--  1 lichunyang  staff    0 11 23 13:04 test.py*
   -rw-r--r--  1 lichunyang  staff  141  9 29 10:11 underscores.txt
   drwxr-xr-x  6 lichunyang  staff  204  7 17 16:38 venv2/
 #+END_SRC
 test.py 权限已经改变
*** 如何调整字符串中文本的格式
 将一个log 文件中的 2018-05-23 的日期格式 转换成 05/23/2018的格式
 #+BEGIN_SRC python
   import re
   log  = open('var/log/dpkg.log').read()

   '''
   re.sub?
   Signature: re.sub(pattern, repl, string, count=0, flags=0)
   Docstring:
   Return the string obtained by replacing the leftmost
   non-overlapping occurrences of the pattern in string by the
   replacement repl.  repl can be either a string or a callable;
   if a string, backslash escapes in it are processed.  If it is
   a callable, it's passed the match object and must return
   '''
   re.sub('(\d{4})-(\d{2})-(\d{2}))', r'\2/\3/\1', log) #注意正则表达式中使用原始字符串
   re.sub('(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2}))',
         r'\g<month>/\g<day>/\g<year>', log)
   # 第一种使用引用计数方法 第二种属于引用名字方法。
 #+END_SRC
** 文件I/O高效处理案例训练
** csv, json, xml, excel 高效解析案例进阶训练
** 类与对象深度技术案例进阶训练
*** 如何派生内置不可变类型并修改其实例化行为？
 案例：我们想自定义一种新类型的元组，对于传入的可迭代对象，我们只保留其中的int类
 型且值大于0的元素，例如：IntTuple([1,-1,'abc',6,['x','y'],3])=>(1,6,3)
 要求IntTuple是内置tuple的子类，如何实现
 #+BEGIN_SRC python
   class IntTuple(tuple):
       def __new__(cls, iterable): #基于__init__中不可改变所以要改变__new__
           g = (x for x in iterable if isinstance(x, int) and x > 0)
           return super(IntTuple, cls).__new__(cls, g)
       def __init__(self, iterable):
           # before 当self实例传入__init__时 tuple已经创建了在这也不能改变
           super(IntTuple, self).__init__(iterable)
           # after self是tuple的实例 tuple是不可变对象 在这改变是不可能的

   t = IntTuple([1, -1, 'abc', 6, ['x', 'y'],3])
   print t
 #+END_SRC
*** 如何为创建大量的实例节省内存？
 实际案例：
 某网络游戏中，定义了玩家类Player（id，name, status,..)每有一个在线的玩家，在服
 务器程序内则有一个Player的实例，当在线人数很多时，将产生大量的实例。（如百万级）
 如何降低这些大量的内存开销？
 解决方案： 定义类的__slots__属性，它是用来声明实例属性名字的列表。
 #+BEGIN_SRC python

   class Player():
       def __init__(self, uid, name, status=0, level=1):
           self.uid = uid
           self.name = name
           self.stat = status
           self.level = level

   class Player2():
       __slots__ = ['uid', 'name', 'stat', 'level']
       def __init__(self, uid, name, status=0, level=1):
           self.uid = uid
           self.name = name
           self.stat = status
           self.level = level

   p1 = Player('0001', 'Jim')
   p2 = Player2('0001', 'Jim')
   print(set(dir(p1)) - set(dir(p2)))
   # 输出
   # In [2]: {'__weakref__', '__dict__'}
   import sys
   print(sys.getsizeof(p1.__dict__))
   print(sys.getsizeof(p2.__slots__))
   # 112
   # 96
 #+END_SRC
 为了节省内存通过定义__slots__方法禁止__dict__动态绑定。
*** 如何让对象支持上下文管理？
 实现上下文管理协议需要定义实例的__enter__,__exit__方法。他们分别在with开始和结
 束时被调用。
*** 如何创建可管理的对象属性？
 #+BEGIN_SRC python
   from math import pi
   class Circle:
       def __init__(self, radius):
           self.radius = radius # 直接利用类属性访问的话 不能确保是数字不能进行操作。

       def getRadius(self):
           return self.radius

       def setRadius(self, value):
           if not isinstance(value, (int, float)):
               raise ValueError('wrong type.')
           self.radius = float(value)

       def getArea(self):
           return self.radius **2 * pi

       R = property(getRadius, setRadius) # 可以传三个值创建访问和删除

   c = Circle(3.2)
   print(c.R)
   c.R = ''
   print(c.R)
 #+END_SRC
 利用property 可以实现c.R的访问属性 访问安全设计灵活。
*** 如何让类支持比较操作？
 #+BEGIN_SRC python
   from functools import total_ordering
   from abc import abstractmethod

   @total_ordering
   class Shape:
       @abstractmethod #实现一个抽象接口子类都需要实现这个接口
       def area(self):
           pass

       def __lt__(self, obj): # 通过 __lt__和 __eq__ 和其他的逻辑组合实现全部的大小比较。
           print('in __lt__') # 通过 @total_ordering 装饰器实现
           if not isinstance(obj, Shape):
               raise TypeError('obje is not Shape')
           return self.area() < obj.area()

       def __eq__(self, obj):
           print ('in __eq__')
           if not isinstance(obj, Shape):
               raise TypeError('obj is not Shape')
           return self.area() == obj.area()

   class Rectangle(Shape):
       def __init__(self, w, h):
           self.w = w
           self.h = h

       def area(self):
           return self.w * self.h

   class Circle(Shape):
       def __init__(self, r):
           self.r = r
       def area(self):
           return self.r ** 2 * 3.14
 #+END_SRC
 两个类的实例是不支持大小比较的 通过复写__lt__ __eq__等方法 可以实现大小比较
*** 如何使用描述符对实例属性做类型检查？
 实际案例：
 在某项目中，我们实现一些类，并希望能像静态语言那样（c, c++, java)对他们的实例属
 性做检查。
 p = Person()
 p.name = 'bob' #必须是str
 p.age = 12 # 必须是int
 p.height = 1.83 # 必须是float

 解决方案：
 使用描述符来实现需要类型检查的属性：分别实现__get__,__set__, __delete__方法，
 在__set__内使用isinstance函数做类型检查
 #+BEGIN_SRC python
   class Arrt:
       def __init__(self, name, type_):
           self.name = name
           self.type_ = type_

       def __get__(self, instance, cls):
           return instance.__dict__[self.name]

       def __set__(self, instance, value):
           if not isinstance(value, self.type_):
               raise TypeError('expected an %s' % self.type_)
           instance.__dict__[self.name] = value

       def __delete__(self, instance):
           del instance.__dict__[self.name]


   class person:
       name = Arrt('name', str)
       age = Arrt('age', int)
       height = Arrt('height', float)


   p = person()
   p.name = 'bob'
   print(p.name)
   p.age = '12'

 output
 In [17]: bob
 ---------------------------------------------------------------------------
 TypeError                                 Traceback (most recent call last)
 <ipython-input-17-6e8dddb352e3> in <module>()
 ----> 1 import codecs, os;__pyfile = codecs.open('''/var/folders/cb/bmq2h1x5559bztw7_k6q6h3r0000gn/T/py20879h9R''', encoding='''utf-8''');__code = __pyfile.read().encode('''utf-8''');__pyfile.close();os.remove('''/var/folders/cb/bmq2h1x5559bztw7_k6q6h3r0000gn/T/py20879h9R''');exec(compile(__code, '''/Users/lichunyang/org/python_base/python_advance.org[*Org Src python_advance.org[ python ]*]''', 'exec'));

 ~/org/python_base/python_advance.org[*Org Src python_advance.org[ python ]*] in <module>()

 ~/org/python_base/python_advance.org[*Org Src python_advance.org[ python ]*] in __set__(self, instance, value)

 TypeError: expected an <class 'int'>
 #+END_SRC
*** 如何在环装数据结构中管理内存？
*** 如何通过实例方法名字的字符串调用方法
 #+BEGIN_SRC python
   from lib1 import Circle #假设三个类中计算面积使用的方法名都不相同
   from lib2 import Triangle #('area','getArea','get_area)
   from lib3 import Rectangle

   def getArea(shape):
       for name in ['area', 'getArea', 'get_area']:
           f = getattr(shape, name, None)
           if f:
               return f()


   shape1 = Circle(2)
   shape2 = Triangle(3, 4, 5)
   shape3 = Rectangle(6, 4)

   shapes = [shape1, shape2, shape3]
   print(map(getArea, shapes))
 #+END_SRC
** 多线程编程核心技术案例进阶训练
** 装饰器使用技巧案例进阶训练

* python 必须模块
** python必学模块-collections
*** nametuple功能详解
 #+BEGIN_SRC python
   from collections import namedtuple

   User = namedtuple('User', ['name', 'age', 'height'])
   user = User(name='lchy', age=29, height=175)
   # In [1]: lchy 29 175
   user_tuple = ('lchy', 24, 185)
   user_list = ['lchy', 26, 180]
   user = User(*user_list)
   # In [2]: lchy 24 185
   user_list = user._make(user_list)
   print("user_list is {}".format(user_list))
   # In [5]: user_list is User(name='lchy', age=26, height=180)
   user_dict = user._asdict()
   print(user_dict)
   # In [3]: OrderedDict([('name', 'lchy'), ('age', 24), ('height', 185)])
   print(user.name, user.age, user.height)
 #+END_SRC
*** defaultdict功能
 当传入key对应的value值不存在时自动生成默认value且volue的结构类型是可以自定义的
 #+BEGIN_SRC python
   from collections import defaultdict

   defaul_dict = defaultdict(int) # 当传入int是value默认为0 传入list默认为[]
   user = ['bob', 'bob', 'jim', 'jim', 'aray']

   for user in user:
       defaul_dict[user] += 1
   print(defaul_dict)
   # In [14]: defaultdict(<class 'int'>, {'bob': 2, 'jim': 2, 'aray': 1})
 #+END_SRC
 #+BEGIN_SRC python
   from collections import defaultdict

   def gen_deafault(): #可以通过自定义函数生成特殊的结构
       return {
           'name': '',
           'nums': 0
       }
   defaul_dict = defaultdict(gen_deafault) 
   defaul_dict['group']
   print(defaul_dict)
   # In [15]: defaultdict(<function gen_deafault at 0x10eff8048>, {'group': {'name': '', 'nums': 0}})
 #+END_SRC
*** Counter
 #+BEGIN_SRC python
   from collections import Counter

   user = ['bob', 'bob', 'jim', 'jim', 'aray']
   user_count = Counter(user)
   print(user_count)
   # In [16]: Counter({'bob': 2, 'jim': 2, 'aray': 1})
   # 按大到小排序
   str_count = Counter('hello world ni hao')
   print(str_count)
   # Counter({'l': 3, 'o': 3, ' ': 3, 'h': 2, 'e': 1, 'w': 1, 'r': 1, 'd': 1, 'n': 1, 'i': 1, 'a': 1})
   str_count2 = Counter('english is a good language')
   print(str_count2)
   print(str_count2.most_common(3))
   # [('g', 4), (' ', 4), ('a', 3)]
 #+END_SRC
*** deque
* python 高级编程和异步IO并发编程
** python 一切皆对象
*** python 一切皆对象
**** 函数和类也是对象，属于python的一等公民
1、赋值给一个变量
2、可以添加到集合对象
3、可以作为参数传递
4、可以当做函数返回
*** class object type 的关系
*** python 常见的内置类型 
**** None （全局只有一个）
**** 数值类型
- int
- float
- complex(复数）
- bool
**** 迭代类型
**** 序列类型
- list
- bytes, bytearray, memoryview(二进制序列)
- range
- tuple
- str 
- array 
**** 映射类型（dict)
**** 集合
- set
- frozenset
**** 上下文管理类型（with)
**** 其他
- 模块类型
- class和实例
- 函数类型
- 方法类型
- 代码类型
- object对象
- type类型
- ellipsis类型（省略号）
- notimplemented类型
** python的魔法函数
*** 什么是魔法函数
    在python中 双下划线开头和双下划线结尾的函数是魔法函数
#+BEGIN_SRC python
  class Company:
      def __init__(self, employee_list):
          self.employee = employee_list

      def __getitem__(self, item):
          return self.employee[item]


  company = Company(['tom', 'bob', 'jame'])        

  for em in company.employee: #没有__getitem__只能这样用
      print(em)

  for em in company: #现在可以这样用
      print(em)
#+END_SRC
通过__getitem__魔法函数可以Company变成可序列类型
*** python数据模型对python的影响
在python中定义魔法函数会对python的操作有影响，比如上面定义了__getitem__后，实例
化对象可以支持切片，迭代、len()等操作，而没有定义时则会报错。
*** 魔法函数一览
**** 非数学运算
***** 字符串表示
__repr__
__str__
***** 集合序列相关
__len__
__getitem__
__setitem__
__delitem__
__contains__
***** 迭代相关
__iter__
__next__
***** 可调用
__call__
***** with上下文管理器
__enter__
__exit__
***** 数值替换
__abs__
__bool__
__init__
__float__
__hash__
__index__
***** 元类相关
__new__
__init__
***** 属性相关
__getattr__
__setattr__
__getattribute__
__setattribute__
__dir__
***** 属性描述符
__get__
__set__
__delete__
***** 协程
__awaite__
__aiter__
__anext__
__aenter__
__aexit__
** 深入类和对象
*** 鸭子类型和多态
#+BEGIN_SRC python
  class Cat(object):
      def say(self):
          print("i am a cat")

  class Dog(object):
      def say(self):
          print("i am a fish")

  class Company(object):
      def __init__(self, employee_list):
          self.employee = employee_list

      def __getitem__(self, item):
          return self.employee[item]

      def __len__(self):
          return len(self.employee)

  company = Company(["tom", "bob", "jane"])

  class Duck(object):
      def say(self):
          print("i am a duck")

  animal_list = [Cat, Dog, Duck]
  for animal in animal_list:
      animal().say()


  dog = Dog()
  a = ["bobby1", "bobby2"]

  b = ["bobby2", "bobby"]
  name_tuple = ["bobby3", "bobby4"]
  name_set = set()
  name_set.add("bobby5")
  name_set.add("bobby6")
  a.extend(dog)
  print(a)
#+END_SRC
extend方法传递一个可迭代对象，可以是list、tuple、set、只因为他们内部有共同的方
法实现了可迭代类型，他们就是可以被extend的，就是鸭子类型。
*** 抽象基类（abc模块）
 #+BEGIN_SRC python
   #我们去检查某个类是否有某种方法
   class Company(object):
       def __init__(self, employee_list):
           self.employee = employee_list

       def __len__(self):
           return len(self.employee)


   com = Company(["bobby1","bobby2"])
   print(hasattr(com, "__len__"))


   class A:
       pass

   class B:
       pass

   #我们在某些情况之下希望判定某个对象的类型
   from collections.abc import Sized
   isinstance(com, Sized)

   b = B()
   print(isinstance(b, A))
   # print(len(com))

   #我们需要强制某个子类必须实现某些方法
   #实现了一个web框架，集成cache(redis, cache, memorychache)
   #需要设计一个抽象基类， 指定子类必须实现某些方法

   #如何去模拟一个抽象基类

   import abc
   from collections.abc import *


   class CacheBase(metaclass=abc.ABCMeta):
       @abc.abstractmethod
       def get(self, key):
           pass

       @abc.abstractmethod
       def set(self, key, value):
           pass
   # class CacheBase():
   #     def get(self, key):
   #         raise NotImplementedError
   #     def set(self, key, value):
   #         raise NotImplementedError
   #
   class RedisCache(CacheBase):
       def set(self, key, value):
           pass

   # redis_cache = RedisCache()
   # redis_cache.set("key", "value")
 #+END_SRC
平时并不推荐使用抽象基类，应该更好的利用python的鸭子类型，和mixin继承方式
*** isinstance和type的区别
#+BEGIN_SRC python
  class A:
      pass

  class B(A):
      pass

  b = B()

  print(isinstance(b, B)) #True
  print(isinstance(b, A)) #True

  print(type(b) is B)  #True
  print(type(b) is A)  #False

  # isinstance检查继承关系， type检查数据类型
#+END_SRC
*** 类变量和实例变量的区别
#+BEGIN_SRC python
  class A:
      aa = 1
      def __init__(self, x, y):
          self.x = x
          self.y = y

  a = A(2,3)

  A.aa = 11
  a.aa = 100 # 此时是实例变量增加了一个aa变量并不是改变了类变量aa中的值。
  print(a.x, a.y, a.aa) #2,3,100 #如果实例的aa变量没有赋值的话，会向上查找类变量aa的值此时返回11
  print(A.aa) # 11

  b = A(3,5)
  print(b.aa) # 11


#+END_SRC
*** 静态方法类方法以及实例方法以及参数
 #+BEGIN_SRC python
   class Date:
       #构造函数
       def __init__(self, year, month, day):
           self.year = year
           self.month = month
           self.day = day

       def tomorrow(self):
           self.day += 1

       @staticmethod #当我们需要处理一些和实例方法和实例参数无关的逻辑时（就是可以在类外面处理的）
 # 为了方便组织代码，把他移到类的内部，使用静态方法
       def parse_from_string(date_str):
           year, month, day = tuple(date_str.split("-"))
           return Date(int(year), int(month), int(day))

       @staticmethod
       def valid_str(date_str):
           year, month, day = tuple(date_str.split("-"))
           if int(year)>0 and (int(month) >0 and int(month)<=12) and (int(day) >0 and int(day)<=31):
               return True
           else:
               return False

       @classmethod #避免实例方法中的类的硬解码传递一个类的参数
       def from_string(cls, date_str):
           year, month, day = tuple(date_str.split("-"))
           return cls(int(year), int(month), int(day))

       def __str__(self):
           return "{year}/{month}/{day}".format(year=self.year, month=self.month, day=self.day)

   if __name__ == "__main__":
       new_day = Date(2018, 12, 31)
       new_day.tomorrow()
       print(new_day)

       #2018-12-31
       date_str = "2018-12-31"
       year, month, day = tuple(date_str.split("-"))
       new_day = Date(int(year), int(month), int(day))
       print (new_day)

       #用staticmethod完成初始化
       new_day = Date.parse_from_string(date_str)
       print (new_day)

       #用classmethod完成初始化
       new_day = Date.from_string(date_str)
       print(new_day)

       print(Date.valid_str("2018-12-32"))
 #+END_SRC
*** python类的私有属性
 python 用双下划线隐藏私有变量，其实内部转换为_classname__attr.
*** python的自省机制
 #+BEGIN_SRC python
   #自省是通过一定的机制查询到对象的内部结构
   from chapter04.class_method import Date
   class Person:
       """
       人
       """
       name = "user"

   class Student(Person):
       def __init__(self, scool_name):
           self.scool_name = scool_name

   if __name__ == "__main__":
       user = Student("慕课网")

       通过__dict__查询属性
       print(user.__dict__)
       user.__dict__["school_addr"] = "北京市"
       print(user.school_addr)
       print(Person.__dict__) #类的属性比实例属性多 而使用dir更加强大
       print(user.name)
       a = [1,2]
       print(dir(a))
 #+END_SRC
*** super真的是调用父类吗？
 #+BEGIN_SRC python
   # from threading import Thread
   # class MyThread(Thread):
   #     def __init__(self, name, user):
   #         self.user = user
   #         super().__init__(name=name)

   #既然我们重写B的构造函数， 为什么还要去调用super？
   #super到底执行顺序是什么样的？

   class A:
       def __init__(self):
           print ("A")

   class B(A):
       def __init__(self):
           print ("B")
           super().__init__()

   class C(A):
       def __init__(self):
           print ("C")
           super().__init__() # 如果注释掉这行结果是 D,B,A吗？结果是D,B,C

   class D(B, C):
       def __init__(self):
           print ("D")
           super(D, self).__init__()

   # if __name__ == "__main__":
   print(D.__mro__) #查看mro顺序
   d = D()

   In [3]: (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, 
 <class '__main__.A'>, <class 'object'>)
   D
   B
   C
   A
 # super调用的其实不是严格意义上的父类 而是以mro顺序去查找
 #+END_SRC
*** python中的mixin
*** python中的with语句
 #+BEGIN_SRC python
   #try except finally
   def exe_try():    #关于try except, finally 的return问题 按执行顺序一次把return结果
       try:          # 压入栈中最后取栈顶的结果
           print ("code started")
           raise KeyError
           return 1
       except KeyError as e:
           print ("key error")
           return 2
       else:  # 当异常不触发是 执行else语句
           print ("other error")
           return 3
       finally:
           print ("finally")
           # return 4

   #上下文管理器协议
   class Sample:
       def __enter__(self):
           print ("enter")
           #获取资源
           return self
       def __exit__(self, exc_type, exc_val, exc_tb):
           #释放资源
           print ("exit")
       def do_something(self):
           print ("doing something")

   with Sample() as sample:
       sample.do_something()

   # if __name__ == "__main__":
   #     result = exe_try()
   #     print (result)
 #+END_SRC
*** 使用contextlib简化上下文管理器
 #+BEGIN_SRC python
   import contextlib

   @contextlib.contextmanager
   def file_open(file_name):
       print ("file open") 类似__enter__
       yield {}
       print ("file end")  类似__exit__

   with file_open("bobby.txt") as f_opened:
       print ("file processing")

 #+END_SRC
** 自定义序列类 
*** 序列类型分类
**** 容器序列 (list, tuple, deque)
**** 扁平序列 (str, bytes, bytearray, array.array)
**** 可变序列 (list, deque, bytearray, arry)
**** 不可变序列 (str, tuple, bytes)
*** list 中的 + += extend append 的区别
#+BEGIN_SRC python
  my_list = []
  my_list.append(1)
  my_list.append("a")

  from collections import abc

  a = [1,2]
  c = a + [3,4]   #只能是同一个类型的对象

  #就地加
  # a += (3,4) #实现的是 extend方法 传递一个可迭代对象
  # 
  # a.extend(range(3))

  a.append((1,2)) # append的是什么就相当于一个元素加入list
  print(a)
#+END_SRC
*** 实现可切片的对象
#+BEGIN_SRC python
  import numbers
  class Group:    # 在collection abc 中找到不可变序列的抽象基类 重写函数
      #支持切片操作
      def __init__(self, group_name, company_name, staffs):
          self.group_name = group_name
          self.company_name = company_name
          self.staffs = staffs

      def __reversed__(self):
          self.staffs.reverse()

      def __getitem__(self, item):
          cls = type(self)
          if isinstance(item, slice):
              return cls(group_name=self.group_name, company_name=self.company_name, staffs=self.staffs[item])
          elif isinstance(item, numbers.Integral):
              return cls(group_name=self.group_name, company_name=self.company_name, staffs=[self.staffs[item]])

      def __len__(self):
          return len(self.staffs)

      def __iter__(self):
          return iter(self.staffs)

      def __contains__(self, item):
          if item in self.staffs:
              return True
          else:
              return False

  staffs = ["bobby1", "imooc", "bobby2", "bobby3"]
  group = Group(company_name="imooc", group_name="user", staffs=staffs)
  reversed(group)
  for user in group:
      print(user)
#+END_SRC
*** bisect维护已排序序列
#+BEGIN_SRC python
  import bisect
  from collections import deque

  #用来处理已排序的序列，用来维持已排序的序列， 升序
  #二分查找
  inter_list = deque()
  bisect.insort(inter_list, 3)
  bisect.insort(inter_list, 2)
  bisect.insort(inter_list, 5)
  bisect.insort(inter_list, 1)
  bisect.insort(inter_list, 6)

  print(bisect.bisect_left(inter_list, 3))
  #学习成绩
  print(inter_list)
#+END_SRC
*** 什么时候应该使用列表，什么时候不使用列表
#+BEGIN_SRC python
  # array, deque
  # 数组
  import array
  #array和list的一个重要区别， array只能存放指定的数据类型
  my_array = array.array("i")
  my_array.append(1)
  my_array.append("abc")
#+END_SRC
*** 列表推导式，生成器，字典推导式
