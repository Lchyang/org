* python 高级编程实战练习
** 数据结构和算法案例进阶训练
*** 如何在列表，字典，集合中根据条件筛选数据？
 列表解析，filter，列表解析的速度是filter的一半左右，字典解析，集合解析
*** 如何为元组中的每个元素命名，提高程序可读性。
 设置常量，替代索引值，元组拆包。 collections中的nametuple
*** 如何统计序列中元素出现频度？
 用字典dict.fromkeys(data,0)创建字典，然后迭代每个key出现value加一
 collections 中 Counter 和 counter.most_common
*** 如何快速找到多个字典中的公共key？
 reduce(lambda a,b: a&b, map(dict.keys(),[data1, data2, data3]))
*** 如何让字典保持有序？
 collections 中 OrderedDict
*** 如何实现用户历史记录功能？
 collections 中 deque
** TODO 对象迭代与反迭代案例进阶训练
   DEADLINE: <2018-12-02 Sun 00:00>
*** 如何实现可迭代对象和迭代器对象
** TODO 字符串处理案例进阶训练
*** 如何拆分含多种分隔符的字符串
 案例：要把某个字符串依据分隔符拆分成不同的字段
 s = 'ab;cd|efg|hi,jkl|mn\topq;rst,uvw\txyz'
 其中，；\ /t都是分隔符，如何处理
 #+BEGIN_SRC python
   # split()方法
   def mySplit(s, ds):
       res = [s]
       for d in ds:
           t = []
           list(map(lambda x: t.extend(x.split(d)), res))
           res = t
       return [x for x in res if x] #当两个分隔符连续时会产生空字符串 过滤掉

   s = 'ab;cd|efg|hi,,jkl|mn\topq;rst,uvw\txyz'
   print(mySplit(s, ';,|\t'))

   # In [7]: ['ab', 'cd', 'efg', 'hi', 'jkl', 'mn', 'opq', 'rst', 'uvw', 'xyz']

   # 方法二： re 模块 re.split
   import re
   print(re.split(r'[,;|\t]+', s))
 #+END_SRC
*** 如何判断字符串a是否以字符串b结尾
 案例：某文件系统目录下有一系列文件：
 quicksort.c
 graph.py
 heap.java
 install.sh
 stack.cpp 
 ...
 编写程序给其中的所有.sh文件和.py文件加上用户权限

 解决方案：使用字符串的str.startswith()和str.endswith()方法
 #+BEGIN_SRC python
   In [18]: ls
   HelloWorld.class  c_test/           test.py           venv2/
   HelloWorld.java   test              underscores.txt

   In [19]: import os, stat

   In [20]: os.listdir('.')
   Out[20]:
   ['.DS_Store',
   'c_test',
   'HelloWorld.class',
   'HelloWorld.java',
   'test',
   'test.py',
   'underscores.txt',
   'venv2']
 # 注意endswith()参数不能是列表。
   In [29]: [name for name in os.listdir('.') if name.endswith(('.sh','.py'))]
   Out[29]: ['test.py']

   In [30]: os.stat('test.py')
   Out[30]: posix.stat_result(st_mode=33188, st_ino=10893185, st_dev=16777220,
                             st_nlink=1, st_uid=501, st_gid=20, st_size=0,
                             st_atime=1542949483, st_mtime=1542949488, st_ctime=1542949488)

   In [31]: os.stat('test.py').st_mode
   Out[31]: 33188

   In [32]: oct(os.stat('test.py').st_mode)
   Out[32]: '0100644'

   In [33]: os.chmod('test.py', os.stat('test.py').st_mode | stat.S_IXUSR)

   In [34]: ls -l
   total 32
   -rw-r--r--  1 lichunyang  staff  425  9 20 13:56 HelloWorld.class
   -rw-r--r--  1 lichunyang  staff  147  9 20 13:56 HelloWorld.java
   drwxr-xr-x  5 lichunyang  staff  170  9 24 22:41 c_test/
   -rw-r--r--  1 lichunyang  staff   62  3 14  2018 test
   -rwxr--r--  1 lichunyang  staff    0 11 23 13:04 test.py*
   -rw-r--r--  1 lichunyang  staff  141  9 29 10:11 underscores.txt
   drwxr-xr-x  6 lichunyang  staff  204  7 17 16:38 venv2/
 #+END_SRC
 test.py 权限已经改变
*** 如何调整字符串中文本的格式
 将一个log 文件中的 2018-05-23 的日期格式 转换成 05/23/2018的格式
 #+BEGIN_SRC python
   import re
   log  = open('var/log/dpkg.log').read()

   '''
   re.sub?
   Signature: re.sub(pattern, repl, string, count=0, flags=0)
   Docstring:
   Return the string obtained by replacing the leftmost
   non-overlapping occurrences of the pattern in string by the
   replacement repl.  repl can be either a string or a callable;
   if a string, backslash escapes in it are processed.  If it is
   a callable, it's passed the match object and must return
   '''
   re.sub('(\d{4})-(\d{2})-(\d{2}))', r'\2/\3/\1', log) #注意正则表达式中使用原始字符串
   re.sub('(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2}))',
         r'\g<month>/\g<day>/\g<year>', log)
   # 第一种使用引用计数方法 第二种属于引用名字方法。
 #+END_SRC
*** 如何将多个小字符串拼接成大的字符串
有字符串['a','b', 1, 2, 'c', 'd']如何拼接成大的字符串

使用+号 每次迭代存在浪费
#+BEGIN_SRC python
  In [38]: l = ['a', 'b','c']

  In [39]: s = ''

  In [40]: for x in l:
      ...:     s += x
      ...:

  In [41]: s
  Out[41]: 'abc'

  In [42]: for x in l:
      ...:     s += x
      ...:     print(s)
      ...:
  abca
  abcab
  abcabc
#+END_SRC

使用str.join()
#+BEGIN_SRC python
  In [44]: l
  Out[44]: ['a', 'b', 'c']

  In [45]: s = ''

  In [46]: ''.join(l)
  Out[46]: 'abc'

  In [47]: l = ['a', 1, 'b'] #当有整数时记得转换成str

  In [48]: ''.join(l)
  ---------------------------------------------------------------------------
  TypeError                                 Traceback (most recent call last)
  <ipython-input-48-9e05f63092b3> in <module>()
  ----> 1 ''.join(l)

  TypeError: sequence item 1: expected str instance, int found

  In [49]: ''.join([str(x) for x in s])
  Out[49]: ''

  In [50]: ''.join([str(x) for x in l]) #使用列表解析存在空间浪费
  Out[50]: 'a1b'

  In [51]: ''.join(str(x) for x in l) #建议使用生成器
  Out[51]: 'a1b'
#+END_SRC
*** 如何对字符串进行左右居中对齐
某个字典中存储了一系列属性值，
{'lodDist': 100.0,
'SmallCull': 0.05,
'DistCull': 500,
'trulinear': 40,
'farclip': 477}
如何将其工整的输出
str.ljust, str.rjust, str.center
#+BEGIN_SRC python
  In [92]: s = 'abc'

  In [96]: s.ljust?
  Docstring:
  S.ljust(width[, fillchar]) -> str

  Return S left-justified in a Unicode string of length width. Padding is
  done using the specified fill character (default is a space).
  Type:      builtin_function_or_method


  In [97]: s.ljust(20)
  Out[106]: 'abc                 '

  In [130]: s.rjust(20, '-')
  Out[146]: '-----------------abc'

  In [147]: s.center(20, '0')
  Out[165]: '00000000abc000000000'
#+END_SRC

使用format
#+BEGIN_SRC python
  In [166]: format?
  Signature: format(value, format_spec='', /)
  Docstring:
  Return value.__format__(format_spec)

  format_spec defaults to the empty string.
  See the Format Specification Mini-Language section of help('FORMATTING') for
  details.
  Type:      builtin_function_or_method


  In [172]: s
  Out[172]: 'abc'

  In [173]: format(s, '<20')
  Out[243]: 'abc                 '

  In [244]: format(s, '>20')
  Out[260]: '                 abc'

  In [261]: format(s, '^20')
  Out[283]: '        abc         '
#+END_SRC

解决问题：
#+BEGIN_SRC python
  In [284]: d = {'lodDist': 100.0,
  'SmallCull': 0.05,
  'DistCull': 500,
  'trulinear': 40,
  'farclip': 477}

  In [291]: d.keys()
  Out[297]: dict_keys(['lodDist', 'SmallCull', 'DistCull', 'trulinear', 'farclip'])

  In [317]: w = max(map(len, d.keys()))

  In [332]: for k in d:
       ...:     print (k.ljust(w), ':', d[k])

  SmallCull : 0.05
  DistCull  : 500
  trulinear : 40
  farclip   : 477

#+END_SRC
*** 如何去掉字符串中不需要的字符

第一种 使用 strip
#+BEGIN_SRC python
  In [65]: s = '   abc 123'

  In [66]: s.strip()
  Out[66]: 'abc 123'

  In [67]: s.strip('3')
  Out[67]: '   abc 12'

  In [68]: s.strip?
  Docstring:
  S.strip([chars]) -> str

  Return a copy of the string S with leading and trailing
  whitespace removed.
  If chars is given and not None, remove characters in chars instead.
  Type:      builtin_function_or_method

  In [69]: s.lstrip()
  Out[69]: 'abc 123'

  In [70]: s.rstrip()
  Out[70]: '   abc 123'

  In [71]: s = '---abc+++'

  In [72]: s.strip('-+')
  Out[72]: 'abc'
#+END_SRC
第二种 使用切片 拼接的方式

第三种：字符串replace方法， 或者使用正则表达式re.sub()删除任意字符
#+BEGIN_SRC python
  In [74]: s
  Out[74]: '\tabc\t123\txyz'

  In [75]: s.replace('\t', '') # replace 只能替换一种字符
  Out[75]: 'abc123xyz'

  In [78]: s = '\tabc\t123\txyz\ropt\r'

  In [79]: import re

  In [80]: re.sub('[\t\r]', '', s)  # re.sub 可以替换多种字符
  Out[80]: 'abc123xyzopt'
#+END_SRC
** 文件I/O高效处理案例训练
*** 如何读写文本文件
**** python2 中读写字符串
python2 中默认的str是二进制编码，支持中文的是unicode字符串
#+BEGIN_SRC python
  In [4]: f = open('py2.txt', 'w')

  In [5]: s = u'你好'

  In [6]: f.write(s.encode('gbk'))

  In [7]: f.close()

  In [9]: f = open('py2.txt', 'r')

  In [10]: t = f.read()

  In [11]: t
  Out[11]: '\xc4\xe3\xba\xc3'

  In [12]: print t.decode('gbk')
  你好
#+END_SRC
**** python3 中读写字符串
python3 中默认的str形式就是unicode形式，二进制形式用 b'abc' 且open函数用t指定文
本模式，encoding 指定编码格式。
#+BEGIN_SRC python
  In [1]: f = open('py3.txt', 'wt', encoding='gbk')

  In [2]: f.write('你好')
  Out[2]: 2

  In [3]: f.close()

  In [4]: f = open('py3.txt', 'rt', encoding='gbk')

  In [5]: print(f.read())
  你好

  In [6]: f.close()
#+END_SRC
** 
** csv, json, xml, excel 高效解析案例进阶训练
** 类与对象深度技术案例进阶训练
*** 如何派生内置不可变类型并修改其实例化行为？
 案例：我们想自定义一种新类型的元组，对于传入的可迭代对象，我们只保留其中的int类
 型且值大于0的元素，例如：IntTuple([1,-1,'abc',6,['x','y'],3])=>(1,6,3)
 要求IntTuple是内置tuple的子类，如何实现
 #+BEGIN_SRC python
   class IntTuple(tuple):
       def __new__(cls, iterable): #基于__init__中不可改变所以要改变__new__
           g = (x for x in iterable if isinstance(x, int) and x > 0)
           return super(IntTuple, cls).__new__(cls, g)
       def __init__(self, iterable):
           # before 当self实例传入__init__时 tuple已经创建了在这也不能改变
           super(IntTuple, self).__init__(iterable)
           # after self是tuple的实例 tuple是不可变对象 在这改变是不可能的

   t = IntTuple([1, -1, 'abc', 6, ['x', 'y'],3])
   print t
 #+END_SRC
*** 如何为创建大量的实例节省内存？
 实际案例：
 某网络游戏中，定义了玩家类Player（id，name, status,..)每有一个在线的玩家，在服
 务器程序内则有一个Player的实例，当在线人数很多时，将产生大量的实例。（如百万级）
 如何降低这些大量的内存开销？
 解决方案： 定义类的__slots__属性，它是用来声明实例属性名字的列表。
 #+BEGIN_SRC python

   class Player():
       def __init__(self, uid, name, status=0, level=1):
           self.uid = uid
           self.name = name
           self.stat = status
           self.level = level

   class Player2():
       __slots__ = ['uid', 'name', 'stat', 'level']
       def __init__(self, uid, name, status=0, level=1):
           self.uid = uid
           self.name = name
           self.stat = status
           self.level = level

   p1 = Player('0001', 'Jim')
   p2 = Player2('0001', 'Jim')
   print(set(dir(p1)) - set(dir(p2)))
   # 输出
   # In [2]: {'__weakref__', '__dict__'}
   import sys
   print(sys.getsizeof(p1.__dict__))
   print(sys.getsizeof(p2.__slots__))
   # 112
   # 96
 #+END_SRC
 为了节省内存通过定义__slots__方法禁止__dict__动态绑定。
*** 如何让对象支持上下文管理？
 实现上下文管理协议需要定义实例的__enter__,__exit__方法。他们分别在with开始和结
 束时被调用。
*** 如何创建可管理的对象属性？
 #+BEGIN_SRC python
   from math import pi
   class Circle:
       def __init__(self, radius):
           self.radius = radius # 直接利用类属性访问的话 不能确保是数字不能进行操作。

       def getRadius(self):
           return self.radius

       def setRadius(self, value):
           if not isinstance(value, (int, float)):
               raise ValueError('wrong type.')
           self.radius = float(value)

       def getArea(self):
           return self.radius **2 * pi

       R = property(getRadius, setRadius) # 可以传三个值创建访问和删除

   c = Circle(3.2)
   print(c.R)
   c.R = ''
   print(c.R)
 #+END_SRC
 利用property 可以实现c.R的访问属性 访问安全设计灵活。
*** 如何让类支持比较操作？
 #+BEGIN_SRC python
   from functools import total_ordering
   from abc import abstractmethod

   @total_ordering
   class Shape:
       @abstractmethod #实现一个抽象接口子类都需要实现这个接口
       def area(self):
           pass

       def __lt__(self, obj): # 通过 __lt__和 __eq__ 和其他的逻辑组合实现全部的大小比较。
           print('in __lt__') # 通过 @total_ordering 装饰器实现
           if not isinstance(obj, Shape):
               raise TypeError('obje is not Shape')
           return self.area() < obj.area()

       def __eq__(self, obj):
           print ('in __eq__')
           if not isinstance(obj, Shape):
               raise TypeError('obj is not Shape')
           return self.area() == obj.area()

   class Rectangle(Shape):
       def __init__(self, w, h):
           self.w = w
           self.h = h

       def area(self):
           return self.w * self.h

   class Circle(Shape):
       def __init__(self, r):
           self.r = r
       def area(self):
           return self.r ** 2 * 3.14
 #+END_SRC
 两个类的实例是不支持大小比较的 通过复写__lt__ __eq__等方法 可以实现大小比较
*** 如何使用描述符对实例属性做类型检查？
 实际案例：
 在某项目中，我们实现一些类，并希望能像静态语言那样（c, c++, java)对他们的实例属
 性做检查。
 p = Person()
 p.name = 'bob' #必须是str
 p.age = 12 # 必须是int
 p.height = 1.83 # 必须是float

 解决方案：
 使用描述符来实现需要类型检查的属性：分别实现__get__,__set__, __delete__方法，
 在__set__内使用isinstance函数做类型检查
 #+BEGIN_SRC python
   class Arrt:
       def __init__(self, name, type_):
           self.name = name
           self.type_ = type_

       def __get__(self, instance, cls):
           return instance.__dict__[self.name]

       def __set__(self, instance, value):
           if not isinstance(value, self.type_):
               raise TypeError('expected an %s' % self.type_)
           instance.__dict__[self.name] = value

       def __delete__(self, instance):
           del instance.__dict__[self.name]


   class person:
       name = Arrt('name', str)
       age = Arrt('age', int)
       height = Arrt('height', float)


   p = person()
   p.name = 'bob'
   print(p.name)
   p.age = '12'

 output
 In [17]: bob
 ---------------------------------------------------------------------------
 TypeError                                 Traceback (most recent call last)
 <ipython-input-17-6e8dddb352e3> in <module>()
 ----> 1 import codecs, os;__pyfile = codecs.open('''/var/folders/cb/bmq2h1x5559bztw7_k6q6h3r0000gn/T/py20879h9R''', encoding='''utf-8''');__code = __pyfile.read().encode('''utf-8''');__pyfile.close();os.remove('''/var/folders/cb/bmq2h1x5559bztw7_k6q6h3r0000gn/T/py20879h9R''');exec(compile(__code, '''/Users/lichunyang/org/python_base/python_advance.org[*Org Src python_advance.org[ python ]*]''', 'exec'));

 ~/org/python_base/python_advance.org[*Org Src python_advance.org[ python ]*] in <module>()

 ~/org/python_base/python_advance.org[*Org Src python_advance.org[ python ]*] in __set__(self, instance, value)

 TypeError: expected an <class 'int'>
 #+END_SRC
*** 如何在环装数据结构中管理内存？
*** 如何通过实例方法名字的字符串调用方法
 #+BEGIN_SRC python
   from lib1 import Circle #假设三个类中计算面积使用的方法名都不相同
   from lib2 import Triangle #('area','getArea','get_area)
   from lib3 import Rectangle

   def getArea(shape):
       for name in ['area', 'getArea', 'get_area']:
           f = getattr(shape, name, None)
           if f:
               return f()


   shape1 = Circle(2)
   shape2 = Triangle(3, 4, 5)
   shape3 = Rectangle(6, 4)

   shapes = [shape1, shape2, shape3]
   print(map(getArea, shapes))
 #+END_SRC
** 多线程编程核心技术案例进阶训练
** 装饰器使用技巧案例进阶训练
*** 如何使用装饰器
某些时候我们想为多个函数，统一添加某种功能，比如计时统计，记录日志，缓存计算等。
我们不想在每个函数内一一添加完全相同的代码，这是就需要用到装饰器

比如为了解决斐波那契数列重复调用的问题，给函数增加缓存。
#+BEGIN_SRC python
  def memo(func):
      cache = {}

      def wrap(*args):
          if args not in cache:
              cache[args] = func(*args)
          return cache[args]
      return wrap


  @memo
  def fibonacci(n):
      if n <= 1:
          return 1
      return fibonacci(n-1) + fibonacci(n-2)


  @memo
  def climb(n, steps):
      count = 0
      if n == 0:
          count = 1
      elif n > 0:
          for step in steps:
              count += climb(n - step, steps)
      return count
#+END_SRC
*** 如何为被装饰的函数保存元数据
在函数对象中保存着一些函数的元数据，例如： 
f.__name__, f.__doc__, f.__moudle__...等。
在我们使用装饰器后，再使用上面这些属性访问时，看到的是内部包裹函数的元数据，原
理的函数的元数据便丢失了。
#+BEGIN_SRC python
  def mydecorator(func):
      def wrapper(*args, **kargs):
          '''wrapper function'''
          print('In wrapper')
          func(*args, **kargs)
      return wrapper


  @mydecorator
  def example():
      '''example function'''
      print('in example')


  print(example.__name__)
  print(example.__doc__)

  # In [44]: example  没有装饰器的结果
  # example function

  # In [45]: wrapper  有装饰器的结果
  # wrapper function
#+END_SRC
如何解决
#+BEGIN_SRC python
  from functools import update_wrapper, wraps


  @wraps #使用update_wrapper 可以解决这个问题，wrap是update_wrapper的快捷函数同样可以.
  def mydecorator(func):
      def wrapper(*args, **kargs):
          '''wrapper function'''
          print('In wrapper')
          func(*args, **kargs)
      # update_wrapper(wrapper, func)
      return wrapper


  @mydecorator
  def example():
      '''example function'''
      print('in example')


  print(example.__name__)
  print(example.__doc__)

  # In [46]: example 
  # example function
#+END_SRC
*** 如何定义带参数装饰器
实现一个装饰器，它用来检查被装饰函数的参数的类型。装饰器可以通过参数指明函数参
数类型，调用时如果检测出类型不匹配这抛出异常。
解决办法：
提取函数的签名：inspect.signature()
带参数的装饰器，依旧是根据参数定制化一个装饰器，可以看成生成生成器的工厂，每次
调用typeassert，返回一个特定的装饰器，然后用它装饰其他函数。
#+BEGIN_SRC python
  from inspect import signature


  def typeassert(*ty_args, **ty_kargs):
      def decorator(func):
          # fnc -> a, b  需要知道函数有哪些参数
          # d = {'a': int, 'b', str} 通过函数参数和传入的类型构造字典()
          sig = signature(func)
          btypes = sig.bind_partial(*ty_args, **ty_kargs).arguments
          # bind_partial 可以允许不同数量的参数进行匹配
          def wrapper(*args, **kargs):
              # for arg in d, isinstance(arg, d[arg]) 迭代字典类型匹配
              for name, obj in sig.bind(*args, **kargs).arguments.items():
                  if name in btypes:
                      if not isinstance(obj, btypes[name]):
                          raise TypeError('"%s" must be "%s"' % (obj, btypes[name]))
              return func(*args, **kargs)
          return wrapper
      return decorator


  @typeassert(int, str, int)
  def f(a, b, c):
      print(a, b, c)

  f(1, 'abc', 2)
  f(1, 2, 3)
#+END_SRC

关于signature的使用
#+BEGIN_SRC python
  In [9]: from inspect import signature

  In [10]: def f(a, b, c=1): pass

  In [11]: sig = signature(f)

  In [12]: sig.parameters
  Out[12]:
  mappingproxy({'a': <Parameter "a">,
                'b': <Parameter "b">,
                'c': <Parameter "c=1">})

  In [13]: a = sig.parameters['a']

  In [14]: a.name
  Out[14]: 'a'

  In [15]: a.kind
  Out[15]: <_ParameterKind.POSITIONAL_OR_KEYWORD: 1>

  In [16]: a = sig.parameters['c']

  In [17]: a.default
  Out[17]: 1

  In [18]: bargs = sig.bind(str, int, int)

  In [19]: bargs.args
  Out[19]: (str, int, int)

  In [20]: bargs.arguments
  Out[20]: OrderedDict([('a', str), ('b', int), ('c', int)])
#+END_SRC
* python 必须模块
** python必学模块-collections
*** nametuple功能详解
 #+BEGIN_SRC python
   from collections import namedtuple

   User = namedtuple('User', ['name', 'age', 'height'])
   user = User(name='lchy', age=29, height=175)
   # In [1]: lchy 29 175
   user_tuple = ('lchy', 24, 185)
   user_list = ['lchy', 26, 180]
   user = User(*user_list)
   # In [2]: lchy 24 185
   user_list = user._make(user_list)
   print("user_list is {}".format(user_list))
   # In [5]: user_list is User(name='lchy', age=26, height=180)
   user_dict = user._asdict()
   print(user_dict)
   # In [3]: OrderedDict([('name', 'lchy'), ('age', 24), ('height', 185)])
   print(user.name, user.age, user.height)
 #+END_SRC
*** defaultdict功能
 当传入key对应的value值不存在时自动生成默认value且volue的结构类型是可以自定义的
 #+BEGIN_SRC python
   from collections import defaultdict

   defaul_dict = defaultdict(int) # 当传入int是value默认为0 传入list默认为[]
   user = ['bob', 'bob', 'jim', 'jim', 'aray']

   for user in user:
       defaul_dict[user] += 1
   print(defaul_dict)
   # In [14]: defaultdict(<class 'int'>, {'bob': 2, 'jim': 2, 'aray': 1})
 #+END_SRC
 #+BEGIN_SRC python
   from collections import defaultdict

   def gen_deafault(): #可以通过自定义函数生成特殊的结构
       return {
           'name': '',
           'nums': 0
       }
   defaul_dict = defaultdict(gen_deafault) 
   defaul_dict['group']
   print(defaul_dict)
   # In [15]: defaultdict(<function gen_deafault at 0x10eff8048>, {'group': {'name': '', 'nums': 0}})
 #+END_SRC
*** Counter
 #+BEGIN_SRC python
   from collections import Counter

   user = ['bob', 'bob', 'jim', 'jim', 'aray']
   user_count = Counter(user)
   print(user_count)
   # In [16]: Counter({'bob': 2, 'jim': 2, 'aray': 1})
   # 按大到小排序
   str_count = Counter('hello world ni hao')
   print(str_count)
   # Counter({'l': 3, 'o': 3, ' ': 3, 'h': 2, 'e': 1, 'w': 1, 'r': 1, 'd': 1, 'n': 1, 'i': 1, 'a': 1})
   str_count2 = Counter('english is a good language')
   print(str_count2)
   print(str_count2.most_common(3))
   # [('g', 4), (' ', 4), ('a', 3)]
 #+END_SRC
*** deque
* python 高级编程和异步IO并发编程
** python 一切皆对象
*** python 一切皆对象
**** 函数和类也是对象，属于python的一等公民
1、赋值给一个变量
2、可以添加到集合对象
3、可以作为参数传递
4、可以当做函数返回
*** class object type 的关系
*** python 常见的内置类型 
**** None （全局只有一个）
**** 数值类型
- int
- float
- complex(复数）
- bool
**** 迭代类型
**** 序列类型
- list
- bytes, bytearray, memoryview(二进制序列)
- range
- tuple
- str 
- array 
**** 映射类型（dict)
**** 集合
- set
- frozenset
**** 上下文管理类型（with)
**** 其他
- 模块类型
- class和实例
- 函数类型
- 方法类型
- 代码类型
- object对象
- type类型
- ellipsis类型（省略号）
- notimplemented类型
** python的魔法函数
*** 什么是魔法函数
    在python中 双下划线开头和双下划线结尾的函数是魔法函数
#+BEGIN_SRC python
  class Company:
      def __init__(self, employee_list):
          self.employee = employee_list

      def __getitem__(self, item):
          return self.employee[item]


  company = Company(['tom', 'bob', 'jame'])        

  for em in company.employee: #没有__getitem__只能这样用
      print(em)

  for em in company: #现在可以这样用
      print(em)
#+END_SRC
通过__getitem__魔法函数可以Company变成可序列类型
*** python数据模型对python的影响
在python中定义魔法函数会对python的操作有影响，比如上面定义了__getitem__后，实例
化对象可以支持切片，迭代、len()等操作，而没有定义时则会报错。
*** 魔法函数一览
**** 非数学运算
***** 字符串表示
__repr__
__str__
***** 集合序列相关
__len__
__getitem__
__setitem__
__delitem__
__contains__
***** 迭代相关
__iter__
__next__
***** 可调用
__call__
***** with上下文管理器
__enter__
__exit__
***** 数值替换
__abs__
__bool__
__init__
__float__
__hash__
__index__
***** 元类相关
__new__
__init__
***** 属性相关
__getattr__
__setattr__
__getattribute__
__setattribute__
__dir__
***** 属性描述符
__get__
__set__
__delete__
***** 协程
__awaite__
__aiter__
__anext__
__aenter__
__aexit__
** 深入类和对象
*** 鸭子类型和多态
#+BEGIN_SRC python
  class Cat(object):
      def say(self):
          print("i am a cat")

  class Dog(object):
      def say(self):
          print("i am a fish")

  class Company(object):
      def __init__(self, employee_list):
          self.employee = employee_list

      def __getitem__(self, item):
          return self.employee[item]

      def __len__(self):
          return len(self.employee)

  company = Company(["tom", "bob", "jane"])

  class Duck(object):
      def say(self):
          print("i am a duck")

  animal_list = [Cat, Dog, Duck]
  for animal in animal_list:
      animal().say()


  dog = Dog()
  a = ["bobby1", "bobby2"]

  b = ["bobby2", "bobby"]
  name_tuple = ["bobby3", "bobby4"]
  name_set = set()
  name_set.add("bobby5")
  name_set.add("bobby6")
  a.extend(dog)
  print(a)
#+END_SRC
extend方法传递一个可迭代对象，可以是list、tuple、set、只因为他们内部有共同的方
法实现了可迭代类型，他们就是可以被extend的，就是鸭子类型。
*** 抽象基类（abc模块）
 #+BEGIN_SRC python
   #我们去检查某个类是否有某种方法
   class Company(object):
       def __init__(self, employee_list):
           self.employee = employee_list

       def __len__(self):
           return len(self.employee)


   com = Company(["bobby1","bobby2"])
   print(hasattr(com, "__len__"))


   class A:
       pass

   class B:
       pass

   #我们在某些情况之下希望判定某个对象的类型
   from collections.abc import Sized
   isinstance(com, Sized)

   b = B()
   print(isinstance(b, A))
   # print(len(com))

   #我们需要强制某个子类必须实现某些方法
   #实现了一个web框架，集成cache(redis, cache, memorychache)
   #需要设计一个抽象基类， 指定子类必须实现某些方法

   #如何去模拟一个抽象基类

   import abc
   from collections.abc import *


   class CacheBase(metaclass=abc.ABCMeta):
       @abc.abstractmethod
       def get(self, key):
           pass

       @abc.abstractmethod
       def set(self, key, value):
           pass
   # class CacheBase():
   #     def get(self, key):
   #         raise NotImplementedError
   #     def set(self, key, value):
   #         raise NotImplementedError
   #
   class RedisCache(CacheBase):
       def set(self, key, value):
           pass

   # redis_cache = RedisCache()
   # redis_cache.set("key", "value")
 #+END_SRC
平时并不推荐使用抽象基类，应该更好的利用python的鸭子类型，和mixin继承方式
*** isinstance和type的区别
#+BEGIN_SRC python
  class A:
      pass

  class B(A):
      pass

  b = B()

  print(isinstance(b, B)) #True
  print(isinstance(b, A)) #True

  print(type(b) is B)  #True
  print(type(b) is A)  #False

  # isinstance检查继承关系， type检查数据类型
#+END_SRC
*** 类变量和实例变量的区别
#+BEGIN_SRC python
  class A:
      aa = 1
      def __init__(self, x, y):
          self.x = x
          self.y = y

  a = A(2,3)

  A.aa = 11
  a.aa = 100 # 此时是实例变量增加了一个aa变量并不是改变了类变量aa中的值。
  print(a.x, a.y, a.aa) #2,3,100 #如果实例的aa变量没有赋值的话，会向上查找类变量aa的值此时返回11
  print(A.aa) # 11

  b = A(3,5)
  print(b.aa) # 11


#+END_SRC
*** 静态方法类方法以及实例方法以及参数
 #+BEGIN_SRC python
   class Date:
       #构造函数
       def __init__(self, year, month, day):
           self.year = year
           self.month = month
           self.day = day

       def tomorrow(self):
           self.day += 1

       @staticmethod #当我们需要处理一些和实例方法和实例参数无关的逻辑时（就是可以在类外面处理的）
 # 为了方便组织代码，把他移到类的内部，使用静态方法
       def parse_from_string(date_str):
           year, month, day = tuple(date_str.split("-"))
           return Date(int(year), int(month), int(day))

       @staticmethod
       def valid_str(date_str):
           year, month, day = tuple(date_str.split("-"))
           if int(year)>0 and (int(month) >0 and int(month)<=12) and (int(day) >0 and int(day)<=31):
               return True
           else:
               return False

       @classmethod #避免实例方法中的类的硬解码传递一个类的参数
       def from_string(cls, date_str):
           year, month, day = tuple(date_str.split("-"))
           return cls(int(year), int(month), int(day))

       def __str__(self):
           return "{year}/{month}/{day}".format(year=self.year, month=self.month, day=self.day)

   if __name__ == "__main__":
       new_day = Date(2018, 12, 31)
       new_day.tomorrow()
       print(new_day)

       #2018-12-31
       date_str = "2018-12-31"
       year, month, day = tuple(date_str.split("-"))
       new_day = Date(int(year), int(month), int(day))
       print (new_day)

       #用staticmethod完成初始化
       new_day = Date.parse_from_string(date_str)
       print (new_day)

       #用classmethod完成初始化
       new_day = Date.from_string(date_str)
       print(new_day)

       print(Date.valid_str("2018-12-32"))
 #+END_SRC
*** python类的私有属性
 python 用双下划线隐藏私有变量，其实内部转换为_classname__attr.
*** python的自省机制
 #+BEGIN_SRC python
   #自省是通过一定的机制查询到对象的内部结构
   from chapter04.class_method import Date
   class Person:
       """
       人
       """
       name = "user"

   class Student(Person):
       def __init__(self, scool_name):
           self.scool_name = scool_name

   if __name__ == "__main__":
       user = Student("慕课网")

       通过__dict__查询属性
       print(user.__dict__)
       user.__dict__["school_addr"] = "北京市"
       print(user.school_addr)
       print(Person.__dict__) #类的属性比实例属性多 而使用dir更加强大
       print(user.name)
       a = [1,2]
       print(dir(a))
 #+END_SRC
*** super真的是调用父类吗？
 #+BEGIN_SRC python
   # from threading import Thread
   # class MyThread(Thread):
   #     def __init__(self, name, user):
   #         self.user = user
   #         super().__init__(name=name)

   #既然我们重写B的构造函数， 为什么还要去调用super？
   #super到底执行顺序是什么样的？

   class A:
       def __init__(self):
           print ("A")

   class B(A):
       def __init__(self):
           print ("B")
           super().__init__()

   class C(A):
       def __init__(self):
           print ("C")
           super().__init__() # 如果注释掉这行结果是 D,B,A吗？结果是D,B,C

   class D(B, C):
       def __init__(self):
           print ("D")
           super(D, self).__init__()

   # if __name__ == "__main__":
   print(D.__mro__) #查看mro顺序
   d = D()

   In [3]: (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, 
 <class '__main__.A'>, <class 'object'>)
   D
   B
   C
   A
 # super调用的其实不是严格意义上的父类 而是以mro顺序去查找
 #+END_SRC
*** python中的mixin
*** python中的with语句
 #+BEGIN_SRC python
   #try except finally
   def exe_try():    #关于try except, finally 的return问题 按执行顺序一次把return结果
       try:          # 压入栈中最后取栈顶的结果
           print ("code started")
           raise KeyError
           return 1
       except KeyError as e:
           print ("key error")
           return 2
       else:  # 当异常不触发是 执行else语句
           print ("other error")
           return 3
       finally:
           print ("finally")
           # return 4

   #上下文管理器协议
   class Sample:
       def __enter__(self):
           print ("enter")
           #获取资源
           return self
       def __exit__(self, exc_type, exc_val, exc_tb):
           #释放资源
           print ("exit")
       def do_something(self):
           print ("doing something")

   with Sample() as sample:
       sample.do_something()

   # if __name__ == "__main__":
   #     result = exe_try()
   #     print (result)
 #+END_SRC
*** 使用contextlib简化上下文管理器
 #+BEGIN_SRC python
   import contextlib

   @contextlib.contextmanager
   def file_open(file_name):
       print ("file open") 类似__enter__
       yield {}
       print ("file end")  类似__exit__

   with file_open("bobby.txt") as f_opened:
       print ("file processing")

 #+END_SRC
** 自定义序列类 
*** 序列类型分类
**** 容器序列 (list, tuple, deque)
**** 扁平序列 (str, bytes, bytearray, array.array)
**** 可变序列 (list, deque, bytearray, arry)
**** 不可变序列 (str, tuple, bytes)
*** list 中的 + += extend append 的区别
#+BEGIN_SRC python
  my_list = []
  my_list.append(1)
  my_list.append("a")

  from collections import abc

  a = [1,2]
  c = a + [3,4]   #只能是同一个类型的对象

  #就地加
  # a += (3,4) #实现的是 extend方法 传递一个可迭代对象
  # 
  # a.extend(range(3))

  a.append((1,2)) # append的是什么就相当于一个元素加入list
  print(a)
#+END_SRC
*** 实现可切片的对象
#+BEGIN_SRC python
  import numbers
  class Group:    # 在collection abc 中找到不可变序列的抽象基类 重写函数
      #支持切片操作
      def __init__(self, group_name, company_name, staffs):
          self.group_name = group_name
          self.company_name = company_name
          self.staffs = staffs

      def __reversed__(self):
          self.staffs.reverse()

      def __getitem__(self, item):
          cls = type(self)
          if isinstance(item, slice):
              return cls(group_name=self.group_name, company_name=self.company_name, staffs=self.staffs[item])
          elif isinstance(item, numbers.Integral):
              return cls(group_name=self.group_name, company_name=self.company_name, staffs=[self.staffs[item]])

      def __len__(self):
          return len(self.staffs)

      def __iter__(self):
          return iter(self.staffs)

      def __contains__(self, item):
          if item in self.staffs:
              return True
          else:
              return False

  staffs = ["bobby1", "imooc", "bobby2", "bobby3"]
  group = Group(company_name="imooc", group_name="user", staffs=staffs)
  reversed(group)
  for user in group:
      print(user)
#+END_SRC
*** bisect维护已排序序列
#+BEGIN_SRC python
  import bisect
  from collections import deque

  #用来处理已排序的序列，用来维持已排序的序列， 升序
  #二分查找
  inter_list = deque()
  bisect.insort(inter_list, 3)
  bisect.insort(inter_list, 2)
  bisect.insort(inter_list, 5)
  bisect.insort(inter_list, 1)
  bisect.insort(inter_list, 6)

  print(bisect.bisect_left(inter_list, 3))
  #学习成绩
  print(inter_list)
#+END_SRC
*** 什么时候应该使用列表，什么时候不使用列表
#+BEGIN_SRC python
  # array, deque
  # 数组
  import array
  #array和list的一个重要区别， array只能存放指定的数据类型
  my_array = array.array("i")
  my_array.append(1)
  my_array.append("abc")
#+END_SRC
*** 列表推导式，生成器，字典推导式
** 深入python的set和dict
*** dict常用方法
#+BEGIN_SRC python
  a = {"bobby1":{"company":"imooc"},
       "bobby2": {"company": "imooc2"}
       }
  #clear
  # a.clear()
  # pass

  #copy, 返回浅拷贝
  new_dict = a.copy()
  new_dict["bobby1"]["company"] = "imooc3"

  #formkeys
  new_list = ["bobby1", "bobby2"]

  new_dict = dict.fromkeys(new_list, {"company":"imooc"})

  new_dict.update((("bobby","imooc"),)) #创建字典神器， 传入可迭代对象 可以传键值
#+END_SRC
*** dict子类
#+BEGIN_SRC python
  #不建议继承list和dict
  class Mydict(dict):
      def __setitem__(self, key, value):
          super().__setitem__(key, value*2)

  my_dict = Mydict(one=1)
  my_dict["one"] = 1
  print (my_dict)

  from collections import UserDict

  class Mydict(UserDict):
      def __setitem__(self, key, value):
          super().__setitem__(key, value*2)

  my_dict = Mydict(one=1)
  # my_dict["one"] = 1
  print (my_dict)

  from collections import defaultdict

  my_dict = defaultdict(dict)
  my_value = my_dict["bobby"]
  pass
#+END_SRC
*** set和frozenset
#+BEGIN_SRC python
  #set 集合 fronzenset (不可变集合) 无序， 不重复
  # s = set('abcdee')
  # s = set(['a','b','c','d','e'])
  s = {'a','b', 'c'}
  # s = frozenset("abcde") #frozenset 可以作为dict的key
  # print(s)

  #向set添加数据
  another_set = set("cef")
  re_set = s.difference(another_set)
  re_set = s - another_set
  re_set = s & another_set
  re_set = s | another_set

  #set性能很高
  # | & -  #集合运算
  print(re_set)

  print (s.issubset(re_set))
  # if "c" in re_set:
  #     print ("i am in set")
#+END_SRC
*** dict和set实现原理
#+BEGIN_SRC python

  from random import randint


  def load_list_data(total_nums, target_nums):
      """
      从文件中读取数据，以list的方式返回
      :param total_nums: 读取的数量
      :param target_nums: 需要查询的数据的数量
      """
      all_data = []
      target_data = []
      file_name = "G:/慕课网课程/AdvancePython/fbobject_idnew.txt"
      with open(file_name, encoding="utf8", mode="r") as f_open:
          for count, line in enumerate(f_open):
              if count < total_nums:
                  all_data.append(line)
              else:
                  break

      for x in range(target_nums):
          random_index = randint(0, total_nums)
          if all_data[random_index] not in target_data:
              target_data.append(all_data[random_index])
              if len(target_data) == target_nums:
                  break

      return all_data, target_data

  def load_dict_data(total_nums, target_nums):
      """
      从文件中读取数据，以dict的方式返回
      :param total_nums: 读取的数量
      :param target_nums: 需要查询的数据的数量
      """
      all_data = {}
      target_data = []
      file_name = "G:/慕课网课程/AdvancePython/fbobject_idnew.txt"
      with open(file_name, encoding="utf8", mode="r") as f_open:
          for count, line in enumerate(f_open):
              if count < total_nums:
                  all_data[line] = 0
              else:
                  break
      all_data_list = list(all_data)
      for x in range(target_nums):
          random_index = randint(0, total_nums-1)
          if all_data_list[random_index] not in target_data:
              target_data.append(all_data_list[random_index])
              if len(target_data) == target_nums:
                  break

      return all_data, target_data


  def find_test(all_data, target_data):
      #测试运行时间
      test_times = 100
      total_times = 0
      import time
      for i in range(test_times):
          find = 0
          start_time = time.time()
          for data in target_data:
              if data in all_data:
                  find += 1
          last_time = time.time() - start_time
          total_times += last_time
      return total_times/test_times


  if __name__ == "__main__":
      # all_data, target_data = load_list_data(10000, 1000)
      # all_data, target_data = load_list_data(100000, 1000)
      # all_data, target_data = load_list_data(1000000, 1000)


      # all_data, target_data = load_dict_data(10000, 1000)
      # all_data, target_data = load_dict_data(100000, 1000)
      # all_data, target_data = load_dict_data(1000000, 1000)
      all_data, target_data = load_dict_data(2000000, 1000)
      last_time = find_test(all_data, target_data)

      #dict查找的性能远远大于list
      #在list中随着list数据的增大 查找时间会增大
      #在dict中查找元素不会随着dict的增大而增大
      print(last_time)

  #1.  dict的key或者set的值 都必须是可以hash的
  #不可变对象 都是可hash的， str， fronzenset， tuple，自己实现的类 __hash__
  #2. dict的内存花销大，但是查询速度快， 自定义的对象 或者python内部的对象都是用dict包装的
  # 3. dict的存储顺序和元素添加顺序有关
  # 4. 添加数据有可能改变已有数据的顺序
#+END_SRC
** 对象引用、可变性和垃圾回收
*** python中的变量是什么？
*** python的垃圾回收和del
*** 一个典型的错误
#+BEGIN_SRC python
  def add(a, b):
      a += b
      return a

  class Company:
      def __init__(self, name, staffs=[]):
          self.name = name
          self.staffs = staffs
      def add(self, staff_name):
          self.staffs.append(staff_name)
      def remove(self, staff_name):
          self.staffs.remove(staff_name)

  if __name__ == "__main__":
      com1 = Company("com1", ["bobby1", "bobby2"])
      com1.add("bobby3")
      com1.remove("bobby1")
      print (com1.staffs)

      com2 = Company("com2") #当com2,com3都不传递list参数是会默认使用defaults参数
      com2.add("bobby")      #会使com2，com3中的数据互相影响
      print(com2.staffs)

      print (Company.__init__.__defaults__)

      com3 = Company("com3")
      com3.add("bobby5")
      print (com2.staffs)
      print (com3.staffs)
      print (com2.staffs is com3.staffs)

      # a = 1
      # b = 2
      #
      # a = [1,2]
      # b = [3,4]
      #
      # a = (1, 2)
      # b = (3, 4)
      #
      # c = add(a, b)
      #
      # print(c)
      # print(a, b)
#+END_SRC
** 元类编程
*** property动态属性
*** __getattr__, __getattribute__ 区别
#+BEGIN_SRC python
  #__getattr__, __getattribute__
  #__getattr__ 就是在查找不到属性的时候调用
  from datetime import date
  class User:
      def __init__(self,info={}):
          self.info = info

      def __getattr__(self, item):
          return self.info[item]

      # def __getattribute__(self, item):
      #     return "bobby"

  if __name__ == "__main__":
      user = User(info={"company_name":"imooc", "name":"bobby"})
      print(user.test)
#+END_SRC
*** 属性描述符和属性查找过程
#+BEGIN_SRC python
  from datetime import date, datetime
  import numbers

  class IntField:
      #数据描述符
      def __get__(self, instance, owner):
          return self.value
      def __set__(self, instance, value):
          if not isinstance(value, numbers.Integral):
              raise ValueError("int value need")
          if value < 0:
              raise ValueError("positive value need")
          self.value = value
      def __delete__(self, instance):
          pass


  class NonDataIntField:
      #非数据属性描述符
      def __get__(self, instance, owner):
          return self.value

  class User:
      age = IntField()
      # age = NonDataIntField()

  '''
  如果user是某个类的实例，那么user.age（以及等价的getattr(user,’age’)）
  首先调用__getattribute__。如果类定义了__getattr__方法，
  那么在__getattribute__抛出 AttributeError 的时候就会调用到__getattr__，
  而对于描述符(__get__）的调用，则是发生在__getattribute__内部的。
  user = User(), 那么user.age 顺序如下：

  （1）如果“age”是出现在User或其基类的__dict__中， 且age是data descriptor， 那么调用其__get__方法, 否则

  （2）如果“age”出现在user的__dict__中， 那么直接返回 obj.__dict__[‘age’]， 否则

  （3）如果“age”出现在User或其基类的__dict__中

  （3.1）如果age是non-data descriptor，那么调用其__get__方法， 否则

  （3.2）返回 __dict__[‘age’]

  （4）如果User有__getattr__方法，调用__getattr__方法，否则

  （5）抛出AttributeError

  '''

  # class User:
  #
  #     def __init__(self, name, email, birthday):
  #         self.name = name
  #         self.email = email
  #         self.birthday = birthday
  #         self._age = 0
  #
  #     # def get_age(self):
  #     #     return datetime.now().year - self.birthday.year
  #
  #     @property
  #     def age(self):
  #         return datetime.now().year - self.birthday.year
  #
  #     @age.setter
  #     def age(self, value):
  #         #检查是否是字符串类型
  #         self._age = value

  if __name__ == "__main__":
      user = User()
      user.__dict__["age"] = "abc"
      print (user.__dict__)
      print (user.age)
      # print (getattr(user, 'age'))
      # user = User("bobby", date(year=1987, month=1, day=1))
      # user.age = 30
      # print (user._age)
      # print(user.age)


#+END_SRC
*** __new__,__init__的区别
#+BEGIN_SRC python
  class User:
      def __new__(cls, *args, **kwargs):
          print (" in new ")
          return super().__new__(cls)
      def __init__(self, name):
          print (" in init")
          pass
  a = int()
  #new 是用来控制对象的生成过程， 在对象生成之前
  #init是用来完善对象的
  #如果new方法不返回对象， 则不会调用init函数
  if __name__ == "__main__":
      user = User(name="bobby")
#+END_SRC
*** 自定义元类
** python Socket编程
*** socket client 实现通信

