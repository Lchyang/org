* python web 开发 
** 数据库
*** 启动/关闭mysql服务 
*** 修改mysql提示符
使用 promapt
\D 完整的日期
\d 当前数据库
\h 服务器名称
\u 当前的用户
prompt \u@\h \d>
*** mysql 常用命令及语法规范
SELECT USER();
SELECT VERSION();
SELECT NOW();
- 关键字与函数名称全部大写
- 数据库名称、表名称、字段名称小写
- sql语句必须以分号结尾
*** 操作数据库
**** 创建数据库
CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name [DEFAULT]
CHARACTER SET [=] charest_name
{}里面是必填 []是选填
CREATE DATABASE t1;
CREATE DATABASE IF NOT EXISTS t1; 这是不会报错会产生警告。
SHOW WARNINGS; 查看警告
CHARACTER SET 表示创建数据库使用的编码格式
CREATE DATABASE IF NOT EXISTS t2 CHARACTER SET gbk;
**** 修改数据库
ALTER {DATABASE | SCHEMA} [db_name] [DEFAULT] CHARACTER SET [=] charset_name
ALTER DATABASE t2 CHARACTER SET = utf8; 修改数据库的编码格式
SHOW CREATE DATABASE t2;  查看数据库的编码格式
**** 删除数据库
DROP {DATABASE | SCHEMA} [IF EXISTS] db_name
*** 数据类型
数据类型是指列、存储过程参数、表达式和局部变量的数据特征，他决定了数据的存储格
式，代表了不同的信息类型
**** 整型
TINYINT  一个字节 0-255
SMALLINT 两个字节 0-65535
MEDIUMINT 三个字节 0-16777215
INT      四个字节 0-2**32-1
BIGINT   八个字节 0-2**64-1
**** 浮点型
FLOAT[(M,D)] M是数字总位数，D是小数点后边的位数。如果省略则根据硬件限制量保存值。
DOUBLE[(M,D)]
**** 日期时间型
YEAR
TIME
DATE
DATETIME
TIMESTAMP
**** 字符型
MySQL数据类型	含义
char(n)	固定长度，最多255个字符
varchar(n)	固定长度，最多65535个字符
tinytext	可变长度，最多255个字符
text	可变长度，最多65535个字符
mediumtext	可变长度，最多2的24次方-1个字符
longtext	可变长度，最多2的32次方-1个字符

char和varchar：
1.char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类
型存储的字符串末尾不能有空格，varchar不限于此。
2.char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的
实际字符数+1个字节（n<=255）或2个字节(n>255)，所以varchar(4),存入3个字符将占用4个字节。 
3.char类型的字符串检索速度要比varchar类型的快。

varchar和text： 
1.varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节
（n<=255）或2个字节(n>255)，text是实际字符数+2个字节。 
2.text类型不能有默认值。 
3.varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于
text,在都创建索引的情况下，text的索引似乎不起作用。
**** 枚举型
ENUM('value1','value2',...)
**** set
SET('value1','value2',...) 最多64个成员，做所有成员的排列组合。
*** 操作数据表
打开数据库 USE databasename;
SELECT DATABASE(); 显示当前打开数据库
**** 创建数据表
CREATE TABLE [IF NOT EXISTS] table_name(
   column_name data_type,
   ...
);

CREATE TABLE tb1( 
username VARCHAR(20), 
age TINYINT UNSIGNED, 
salary FLOAT(8,2) UNSIGNED
);
**** 查看数据表
SHOW TABLES [FROM db_name] [LIKE 'pattern' | WHERE expr]

SHOW TABLES; 查看当前数据库中的表
SHOW TABLES FROM mysql; 查看其它数据库中的表
**** 查看数据表的结构 
SHOW COLUMNS FROM tbl_name;
SHOW COLUMNS FROM tb1; 查看 tb1 表的结构

root@localhost test>SHOW COLUMNS FROM tb1;
+----------+---------------------+------+-----+---------+-------+
| Field    | Type                | Null | Key | Default | Extra |
+----------+---------------------+------+-----+---------+-------+
| username | varchar(20)         | YES  |     | NULL    |       |
| age      | tinyint(3) unsigned | YES  |     | NULL    |       |
| salary   | float(8,2) unsigned | YES  |     | NULL    |       |
+----------+---------------------+------+-----+---------+-------+
3 rows in set (0.01 sec)
**** mysql 记录的插入与查找
***** 插入记录
INSERT [INFO] tbl_name [(col_name,..)] VALUES (val,..)

root@localhost test>INSERT tb1 VALUES('tom',25,342.23);
Query OK, 1 row affected (0.01 sec)

root@localhost test>SHOW COLUMNS FROM tb1;
+----------+---------------------+------+-----+---------+-------+
| Field    | Type                | Null | Key | Default | Extra |
+----------+---------------------+------+-----+---------+-------+
| username | varchar(20)         | YES  |     | NULL    |       |
| age      | tinyint(3) unsigned | YES  |     | NULL    |       |
| salary   | float(8,2) unsigned | YES  |     | NULL    |       |
+----------+---------------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

root@localhost test>INSERT tb1(username, salary) VALUES('john', 450.23);
Query OK, 1 row affected (0.01 sec)
***** 记录的查找
SELECT expr,.. FROM tabl_name;

root@localhost test>SELECT * FROM tb1;
+----------+------+--------+
| username | age  | salary |
+----------+------+--------+
| tom      |   25 | 342.23 |
| john     | NULL | 450.23 |
+----------+------+--------+
2 rows in set (0.00 sec)
**** mysql 的空值与非空
NULL, 字段值可以为空
NOT NULL, 字段值禁止为空

root@localhost test>CREATE TABLE tb2(
    -> username VARCHAR(20) NOT NULL,
    -> age TINYINT UNSIGNED NULL
    -> );
Query OK, 0 rows affected (0.03 sec)

root@localhost test>SHOW COLUMNS FROM tb2;
+----------+---------------------+------+-----+---------+-------+
| Field    | Type                | Null | Key | Default | Extra |
+----------+---------------------+------+-----+---------+-------+
| username | varchar(20)         | NO   |     | NULL    |       |
| age      | tinyint(3) unsigned | YES  |     | NULL    |       |
+----------+---------------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

root@localhost test>INSERT tb2 VALUES('tom', NULL);
Query OK, 1 row affected (0.00 sec)

root@localhost test>SELECT * FROM tb2;
+----------+------+
| username | age  |
+----------+------+
| tom      | NULL |
+----------+------+
1 row in set (0.00 sec)

root@localhost test>INSERT tb2 VALUES(NULL, 22);
ERROR 1048 (23000): Column 'username' cannot be null
**** mysql 自动编号（AUTO_INCREMENT)
自动编号，必须和主键组合使用
默认情况下，起始值为1， 每次增量为1
AUTO_INCREMENT 必须和主键一起使用，主键不必须有 AUTO_INCREMENT
**** 主键约束
每张表只能存在一个主键
主键保证记录的唯一性
主键自动为NOT NULL

root@localhost test>CREATE TABLE tb3(
    -> id SMALLINT UNSIGNED AUTO_INCREMENT KEY,
    -> username VARCHAR(30) NOT NULL
    -> );
Query OK, 0 rows affected (0.02 sec)

root@localhost test>SHOW COLUMNS FROM tb3;
+----------+----------------------+------+-----+---------+----------------+
| Field    | Type                 | Null | Key | Default | Extra          |
+----------+----------------------+------+-----+---------+----------------+
| id       | smallint(5) unsigned | NO   | PRI | NULL    | auto_increment |
| username | varchar(30)          | NO   |     | NULL    |                |
+----------+----------------------+------+-----+---------+----------------+
2 rows in set (0.01 sec)

root@localhost test>INSERT tb3(username) VALUES('tom');
Query OK, 1 row affected (0.01 sec)

root@localhost test>INSERT tb3(username) VALUES('john');
Query OK, 1 row affected (0.00 sec)

root@localhost test>INSERT tb3(username) VALUES('bob');
Query OK, 1 row affected (0.00 sec)

root@localhost test>SELECT * FROM tb3;
+----+----------+
| id | username |
+----+----------+
|  1 | tom      |
|  2 | john     |
|  3 | bob      |
+----+----------+
3 rows in set (0.00 sec)

如果没有AUTO_INCREMENT 主键得手动赋值。

root@localhost test>CREATE TABLE tb4(
    -> id SMALLINT UNSIGNED KEY,
    -> username VARCHAR(20) NOT NULL
    -> );
Query OK, 0 rows affected (0.03 sec)

root@localhost test>SHOW COLUMNS FROM tb4;
+----------+----------------------+------+-----+---------+-------+
| Field    | Type                 | Null | Key | Default | Extra |
+----------+----------------------+------+-----+---------+-------+
| id       | smallint(5) unsigned | NO   | PRI | NULL    |       |
| username | varchar(20)          | NO   |     | NULL    |       |
+----------+----------------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

root@localhost test>INSERT tb4(username) VALUES('tom');
ERROR 1364 (HY000): Field 'id' doesn't have a default value
root@localhost test>INSERT tb4 VALUES(2,'tom');
Query OK, 1 row affected (0.00 sec)

root@localhost test>INSERT tb4 VALUES(4,'tom');
Query OK, 1 row affected (0.00 sec)

root@localhost test>SELECT * FROM tb4;
+----+----------+
| id | username |
+----+----------+
|  2 | tom      |
|  4 | tom      |
+----+----------+
2 rows in set (0.00 sec)
**** mysql 初涉唯一约束
唯一约束可以保证记录的唯一性
唯一约束的字段可以为空值（NULL）
每张数据表可以存在多个唯一约束

root@localhost test>CREATE TABLE tb5( 
id SMALLINT UNSIGNED AUTO_INCREMENT KEY, 
username VARCHAR(20) NOT NULL UNIQUE KEY, 
age TINYINT UNSIGNED);
Query OK, 0 rows affected (0.02 sec)

root@localhost test>SHOW COLUMNS FROM tb5;
+----------+----------------------+------+-----+---------+----------------+
| Field    | Type                 | Null | Key | Default | Extra          |
+----------+----------------------+------+-----+---------+----------------+
| id       | smallint(5) unsigned | NO   | PRI | NULL    | auto_increment |
| username | varchar(20)          | NO   | UNI | NULL    |                |
| age      | tinyint(3) unsigned  | YES  |     | NULL    |                |
+----------+----------------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)

root@localhost test>INSERT tb5(username,age) VALUES('Tom',22);
Query OK, 1 row affected (0.00 sec)

root@localhost test>INSERT tb5(username,age) VALUES('Tom',22);
ERROR 1062 (23000): Duplicate entry 'Tom' for key 'username'
唯一约束，字段的key不可以重复
**** 初涉默认约束
当插入记录时，如果没有明确的字段赋值，则自动赋予默认值。 
root@localhost test>CREATE TABLE tb6(
    -> id SMALLINT UNSIGNED AUTO_INCREMENT KEY,
    -> username VARCHAR(20) NOT NULL UNIQUE KEY,
    -> sex ENUM('1','2','3') DEFAULT '3'
    -> );
Query OK, 0 rows affected (0.02 sec)

root@localhost test>SHOW COLUMNS FROM tb6;
+----------+----------------------+------+-----+---------+----------------+
| Field    | Type                 | Null | Key | Default | Extra          |
+----------+----------------------+------+-----+---------+----------------+
| id       | smallint(5) unsigned | NO   | PRI | NULL    | auto_increment |
| username | varchar(20)          | NO   | UNI | NULL    |                |
| sex      | enum('1','2','3')    | YES  |     | 3       |                |
+----------+----------------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)

root@localhost test>INSERT tb6(username) VALUES('Tom');
Query OK, 1 row affected (0.00 sec)

root@localhost test>SELECT * FROM tb6;
+----+----------+------+
| id | username | sex  |
+----+----------+------+
|  1 | Tom      | 3    |
+----+----------+------+
1 row in set (0.00 sec)

** tcp/ip
** 数据结构，算法
** python 语言
** linux系统
*** ln
ln 链接两个文件 是硬链接 在磁盘上开辟新的空间
ln -f 如果链接已经存在 可以重置链接
ln -s 软链接 不在磁盘开辟新的空间 而是新建一个小文件来记录链接

ln 和 ln -s 区别 如果ln删除源文件 链接文件还可以用 ln -s不可以
*** mkdir
mkdir -p a/b/c
mkdir -v a 创建完成后返回创建是否成功信息
*** cp
cp a.txt b.txt
cp a.txt b.txt foo
cp -v a.txt b.txt
cp -f 相当于强制cp当权限不允许的情况下
cp -i 提示是否覆盖已有文件
cp -r foo bar copy文件夹时
*** rm
    rm 和 cp 用法类似
*** Input/Output(|,>)
'|' We can build some pretty impressive work flows by redirecting the output of
one command to the input to another command. This is made possible by using the
"pipe" operator, '|'.
If we instead wated to read data from a file, we can use <.
*** grep
grep django requirements.txt
grep "d..n" requirements.txt 使用正则表达式
grep -c django requirements.txt 计算出现次数
grep -n django requirements.txt 显示行号
grep -i django requirements.txt 忽略大小写
grep djanog requirements.txt django.txt 从多个文件中搜索
gerp -r django ctyun 从文件中搜索
grep -r --include="*.py" "django" ctyun 从ctyun文件夹的.py 文件中搜索django
grep -v "a" requirements.txt 搜索不包含a的所有行
grep -v "^$" requirements | grep -v "a" 搜索包含空行的非字符a的行
*** ps
ps
ps u
ps -e 显示所有线程
ps -U root /ps -U lichunyang
ps -L
ps -O etime,%cpu,%mem
ps -m -O %mem -u root 根据占用内存排序
ps -r -O %cpu -u root 根据占用cpu排序

** django 项目
*** django 部署（nginx + gunicorn)
gunicorn --bind "localhost:8000" mblog.wsgi
localhost:8000 是运行的端口 mblog 在 manage.py 的文件夹目录下

nginx
server {
    charset utf-8;
    listen 80;
    server_name demo.zmrenwu.com; ①

    location /static { ②
        alias /home/yangxg/sites/demo.zmrenwu.com/django-blog-tutorial/static; 
    }

    location / { ③
        proxy_set_header Host $host;
        proxy_pass http://unix:/tmp/demo.zmrenwu.com.socket;
    }
}
使用非root用户 log /var/log/nginx/error.log 配置/etc/nginx/sites-av../
1 域名或者ip
2 当路径中写static 用 alias  没有写用 root
3 proxy_pass 不能用localhost代替127.0.0.1
** celery
celery 是一个简单、灵活且可靠的、处理大量消息的分布式系统
专注于实时处理异步任务队列
同时也支持任务调度
*** 使用场景
异步任务： 将耗时操作任务提交给celery去异步执行，比如发送短信/邮件、消息推送、
音视频处理等
定时任务： 类似于crontab， 比如每日数据统计
*** Celery 基本使用
tasks.py
#+BEGIN_SRC python
  import time
  from celery import Celery


  broker = 'redis://localhost:6379/1'
  backend = 'redis://localhost:6379/2'
  app = Celery('my_stacks', broker=broker, backend=backend)


  @app.task
  def add(x, y):
      print('enter call func..')
      time.sleep(4)
      return x + y
#+END_SRC
test_celery.py
#+BEGIN_SRC python
  from tasks import add

  if __name__ == '__main__':
      print('start task...')
      result = add.delay(2, 8)
      print('end stask... ')
      print(result)
#+END_SRC
基本命令
#+BEGIN_SRC python
  In [1]: from tasks import add

  In [2]: add.delay(2,8)
  Out[2]: <AsyncResult: d368f92c-a938-4ec3-aa28-bb046275d948>

  In [3]: result = add.delay(2,9)

  In [4]: result.ready()
  Out[4]: True

  In [5]: result.get()
  Out[5]: 11
#+END_SRC
*** Celery 配置文件
celery_app.__init__.py
#+BEGIN_SRC python
  from celery import Celery


  app = Celery('demo')
  # 通过 celery 实例加载配置模块
  app.config_from_object('celery_app.celeryconfig')
#+END_SRC
celery_app.celeryconfig.py
#+BEGIN_SRC python
  BROKER_URL = 'redis://localhost:6379/1'

  CELERY_RESULT_BACKEND = 'redis://localhost:6379/2'

  CELERY_TIMEZONE = 'Asia/Shanghai'

  # 导入制定模块
  CELERY_IMPORTS = (
      'celery_app.task1',
      'celery_app.task2'
  )

#+END_SRC
celery_app.task1.py
#+BEGIN_SRC python
  import time

  from celery_app import app


  @app.task
  def add(x, y):
      time.sleep(3)
      return x + y

#+END_SRC
celery_app.task2.py
#+BEGIN_SRC python
  import time

  from celery_app import app


  @app.task
  def multiply(x, y):
      time.sleep(4)
      return x * y

#+END_SRC

test_celery.py
#+BEGIN_SRC python
  from celery_app import task1, task2


  task1.add.delay(2, 4)
  task2.multiply.delay(4, 5)
  print('end...')
#+END_SRC
通过 celery worker -A celery_app -l INFO 命令启动worker
然后运行 python test_celery.py 
*** 定时任务
#+BEGIN_SRC python
  from datetime import timedelta
  from celery.schedules import crontab

  BROKER_URL = 'redis://localhost:6379/1'

  CELERY_RESULT_BACKEND = 'redis://localhost:6379/2'

  CELERY_TIMEZONE = 'Asia/Shanghai'

  # 导入制定模块
  CELERY_IMPORTS = (
      'celery_app.task1',
      'celery_app.task2'
  )

#定时任务
  CELERYBEAT_SCHEDULE = {
      'task1': {
          'task': 'celery_app.task1.add',
          'schedule': timedelta(seconds=10),
          'args': (2, 8),
      },
      'task2': {
          'task': 'celery_app.task2.multiply',
          'schedule': crontab(hour=19, minute=14),
          'args': (4, 5)
      }
  }
#+END_SRC
启动 任务
celery worker -A celery_app -l INFO
celery beat -A celery_app -l INFO
*** Django 中使用celery
pip install django-celery 

在setting同目录下创建celeryconfig.py文件
#+BEGIN_SRC python
  from datetime import timedelta
  import djcelery

  djcelery.setup_loader()

  CELERY_QUEUES = {
      # 定时任务
      'beat_tasks': {
          'exchange': 'beat_tasks',
          'exchange_type': 'direct',
          'binding_key': 'beat_tasks',
      },
      # 普通任务
      'work_queue': {
          'exchange': 'work_queue',
          'exchange_type': 'direct',
          'binding_key': 'work_queue',
      }
  }

  # 默认任务
  CELERY_DEFAULT_QUEUE = 'work_queue'


  CELERY_IMPORTS = (
      'blog.tasks',
  )

  # 有些情况可以防止死锁
  CELERYD_FORCE_EXECV = True

  # 设置并发的worker数量
  CELERYD_CONCURRENCY = 4

  # 允许重试
  CELERY_ACKS_LATE = True

  # 每个worker最多执行100个任务被销毁，可是防止内存泄漏
  CELERYD_MAX_TASKS_PER_CHILD = 100

  #单个任务的最大运行时间
  CELERYD_TASK_TIME_LIMIT = 12 * 30

  # 定时任务
  CELERYBEAT_SCHEDULE = {
      'task1': {
          'task': 'course_task',
          'schedule': timedelta(seconds=5),
           # 'args': ()
          'options': {
              'queue': 'beat_tasks'
          }
      }
  }
#+END_SRC

在app中注册 djcelery 在setting.py 中增加
#+BEGIN_SRC python
  #celery
  from .celeryconfig import *  #使celeryconfig 和setting联系
  # redis 配置
  BROKER_BACKEND = 'redis' 
  BROKER_URL = 'redis://localhost:6379/1'
  CELERY_RESULT_BACKEND = 'redis://localhost:6379/2'
#+END_SRC

在应用下创建task.py文件
#+BEGIN_SRC python
  import time

  from celery.task import Task


  class CourseTask(Task):
      name = 'course_task'

      def run(self, *args, **kwargs):
          print('start course task')
          time.sleep(4)
          print('args={}, kwargs={}'.format(args, kwargs))
          print('end course task')
#+END_SRC

在views中
#+BEGIN_SRC python
  from django.http import JsonResponse

  from blog.tasks import CourseTask


  def do(request):
      # 执行异步
      print('start do request')
      CourseTask.delay()
      print('end do request')
      return JsonResponse({'result': 'ok'})
#+END_SRC

配置url访问views
运行时 python managge.py runserver,   python manage.py celery worker -l INFO
运行定时任务要加上  python manage.py celery beat -l INFO
* linux基础 
** 学会使用命令帮助
whatis command 简要说明命令的作用
whatis -w 'l*' 正则匹配
info command 更加详细的说明文档
man command 查询command说明文档
which command 查看文件所在路径
whereis command 查看程序的搜索路径
当系统中安装了同一个软件的多个版本时，不确定用的是哪个版本时，这个命令就排上了
用场
** 文件目录管理
*** 创建和删除
- 创建：mkdir
- 删除：rm
- 删除非空目录： rm -rf file
- 删除日志 rm *log (等价 find ./ -name '*log' -exec rm {};)
- 移动： mv
- 复制：cp （复制目录：cp -r）
查看当前目录下文件个数
find ./ | wc -l
